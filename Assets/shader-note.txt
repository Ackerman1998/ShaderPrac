#shader数学基础
基本属性：
vertex 顶点 , 图元 , fragment 片元 
顶点构成的点,线段,多边形称为图元;但在相机空间下,不在视野内的图元会被裁剪,
裁剪图元得到的坐标将会被转换为屏幕坐标,裁剪的图元经过光栅化得到片元

#顶点着色器
顶点着色器需要完成的工作：变换顶点坐标,将顶点坐标从模型空间变换到裁剪空间,
逐顶点光照.(计算光照有两种方式：逐顶点光照，逐片元光照)

#裁剪
不在视野范围内的图元将被裁剪,得到的图元将传递给片元着色器进行下一步操作
#屏幕映射
将裁剪空间下的坐标转换到屏幕坐标空间下.

#模型空间,世界空间,相机空间,裁剪空间,屏幕空间
模型空间.世界空间都是左手坐标系
相机空间是右手坐标系
相机前方的方向就是相机空间的-z方向,当相机向-z方向移动时,场景深度增加

#点,矢量(或称向量),标量
点就是多维空间中一个位置
矢量就是由模和方向构成的有向线段,举例:车子速度=向东80km/h,向东就是方向,80km/h就是模
标量只有模,没有方向,例如距离80km.
在数学表示上,点和矢量的表示非常相似,在三维空间中都是用(x,y,z)表示
假设有一个点(x,y,z),从原点到这个点的偏移量就是(x,y,z)
矢量一般用来表示相对位置,偏移量
|v|向量的模
^v向量的单位向量
#矢量计算(加减法)
加法a+b:略
减法a-b:从b的尾部连接到a的尾部(b指向a)
单位向量 (x,y)=(x,y)/(x,y的平方根)
点积,叉积:
点积:a·b 几何意义:b在a上的投影 a·b*cos ab
叉积:axb 几何意义:两者相乘得到的向量垂直于a,b所在的平面;unity中,模型的切线同时垂直于法线和垂线
叉乘计算:
例题:(-5,4,1)x(3,-1,2)
题解1:向量a(x,y,z)垂直于两个向量同处的平面,利用该特性,用向量a和另外两个向量进行点乘计算
可得到两个方程式:
-5x+4y+z=0
3x-y+2z=0
可解得:13x=9y  ,  7x=-9y   ,   7y=-13z  
进而得到:x=9y/13  ,  y  , z = -7y/13
即(9/13,1,-7/13),再将其乘以13得到(9,13,-7)
(9,13,-7)就是我们要求的叉乘

#矩阵
#对矩阵相乘的理解
|1 0  0 0|  |1 0 0 0| 
|0 1  0 0|\/|0 1 1 1|
|0 0 -1 0|/\|0 1 1 1| 
|0 0  0 0|  |0 0 0 1|
第一个矩阵中横向观察可得到四个矢量(1,0,0,0),(0,1,0,0),(0,0,-1,0),(0,0,0,0)
第二个矩阵中纵向观察可得到四个矢量(1,0,0,0),(0,1,1,1),(0,1,1,1),(0,0,0,1)
若要对矩阵的z坐标取反,则只需对第一个矩阵的第三行的z值取反即可.
或者直接对要改变的矩阵的z值全部取反即可.
1.方块矩阵(行列数相等的矩阵)
2.单位矩阵(任何矩阵乘以它还是等于原来的值)
1 0 0
0 1 0
0 0 1
3.转置矩阵:将i行变成i列,j列变为j行
4.逆矩阵(逆矩阵必须是方块矩阵)方阵乘以逆矩阵等于单位矩阵
 1  2
-1 -3
待定系数法求解:
| 1  2|.|a b|=|1 0|   |  a+2c   b+2d|=|1 0|
|-1 -3| |c d| |0 1| =>| -a-3c  -b-3d|=|0 1|
得到=> a+2c=1,b+2d=0,-a-3c=0,-b-3d=1
a=3
b=2
c=-1
d=-1
逆矩阵=
 3  2
-1 -1
5.正交矩阵(方阵与转置矩阵的乘积等于单位矩阵)

#矩阵的变换:
三维矩阵不能进行平移变换,必须拓展到四维矩阵,并引入齐次坐标方便计算.
齐次坐标是四维矢量(x,y,z,w),当该三维矢量是一个点时,w分量设为1;当是一个方向矢量时,w分量=0

#矩阵的平移
首先对点(x,y,z,1)进行平移,
|1 0 0 a|  |x|  |x+a|
|0 1 0 b|  |y|=>|y+b|=>(x+a,y+b,z+c,1)
|0 0 1 c|  |z|  |z+c|
|0 0 0 1|  |1|  |1  |
对方向矢量进行平移
|1 0 0 a|  |x|  |x|
|0 1 0 b|  |y|=>|y|=>(x,y,z,0),方向矢量不存在平移的概念
|0 0 1 c|  |z|  |z|
|0 0 0 1|  |0|  |0|

#矩阵的缩放
对点(x,y,z,1)进行缩放,
|a 0 0 0|  |x|  |xa|
|0 b 0 0|  |y|=>|yb|=>(xa,yb,zc,1)
|0 0 c 0|  |z|  |zc|
|0 0 0 1|  |1|  |1 |

#矩阵的旋转
绕着x轴旋转,x坐标不变,y,z坐标改变
#复合变换
先缩放,后旋转,后平移(顺序不能乱)
#unity中空间的变换
模型空间->世界空间(模型变换):两个空间都采用左手坐标系
从模型空间变换到世界空间时,假设模型上有一个A点(1,2,3),模型的世界空间pos坐标=(10,0,0),rotate坐标=(0,140,0),scale坐标=(2,2,2)代表
模型变换时进行了缩放2倍,绕Y轴旋转140°,平移x轴10个单位.此时我们若要得到模型上的A点的世界坐标,则要按照前面的变换规则进行变换.

观察空间(摄像机空间):采用右手坐标系,摄像机的+z轴指向摄像机的后方
左手坐标系和右手的区别:+y轴都是向上,+x轴都是向右,不同的是左手坐标系是+z轴向前,右手的
是向后,这一特性正好和Directx(左手),OpenGL(右手)的特性一致.

世界空间->观察空间(观察变换):
先平移,后旋转,再缩放,因为坐标系的不同,左手,右手的坐标系相反,z坐标需要取反,变换好的矩阵再和需要
变换的点相乘便可得到观察空间下的坐标.

观察空间->裁剪空间或称齐次裁剪空间(裁剪变换):
要转化的点与投影矩阵作乘积得到点的裁剪坐标,通过判断坐标是否在裁剪空间中(即判断-w<=x(yz)<=w),若都在,
那就不需要裁剪

裁剪空间->屏幕空间
先做齐次除法(也称归一化坐标)将坐标都转化到一个立方体中(用x,y坐标去除以w),使用公式书籍P84的公式来
计算得到屏幕坐标,一般z坐标系统会存储好可作深度缓冲用.

总结:
平移时使用4阶矩阵进行运算,w分量设为0或1(0为点,1为向量);旋转和缩放只需使用三阶矩阵进行运算

#shader使用
###一些关键字###
SV_POSITION:可以看作一个标识,代表这个值是顶点在裁剪空间下的位置

#常用的包含文件
UnityCG.cginc 最常使用的函数，宏，结构体
Lighting.cginc 各种内置的光照模型.
#标准光照模型
自发光,高光反射,漫反射,环境光
Shader:Ackerman/DiffuseShader
漫反射实现过程:(逐顶点光照)
1.变换顶点坐标到裁剪空间
2.获取环境光的方向向量
3.将模型的法线向量变换到世界空间下，并归一化
4.获取场景中的灯光(例如平行光)的方向向量，并归一化.
常用变量/函数:

(fixed3x3)unity_WorldToObject：模型变换矩阵
UNITY_LIGHTMODEL_AMBIENT：环境光
_WorldSpaceLightPos0：平行光
_LightColor0：场景中灯光的颜色
POSITION:模型空间下的顶点位置
NORMAL:顶点法线
TANGENT:顶点切线
TEXCOORDn比如:TEXCOORD0:该顶点的纹理坐标,第一组纹理坐标
COLOR:顶点颜色
SV_POSITION:裁剪空间的顶点坐标
SV_TARGET:输出的值将会存放在渲染目标中.
_WorldSpaceCameraPos:相机在世界空间下的坐标
UnityWorldSpaceLightDir(模型位置):获取基于当前模型位置的平行光源的方向矢量

3种数据精度类型:
float 最高精度的浮点，通常使用32位存储
half  中等精度的浮点，通常使用16位存储，范围[-60000,+60000]
fixed 最低精度的浮点，通常使用11位存储,范围[-2,+2]
漫反射计算:diffuse=灯光颜色*可调颜色*投影方向向量

半兰伯特模型计算漫反射光照与之前两种计算方式对比：
模型背光面不会颜色都是一样黑，像一个平面一样，模型细节表现不出来。
在计算方向矢量时应该作归一化

Shader "Ackerman/SpecularShader"高光反射光照模型
不完全符合真实世界中的高光反射现象，用于计算那些沿着完全镜面反射方向被反射的光线，可以让物体看起来有光泽，比如金属材质。
求法：灯光颜色*自定义颜色*(反射方向向量和视角方向向量的点积);视角方向向量：相机世界坐标-模型顶点的世界坐标
pow(a,b)=求a的b次幂
saturate(a)将a的值限制在[0,1]范围内
reflect(a,b)求向量a在b作为法线下得到的反射向量
dot(a,b)求向量b在a上的投影,点积满足交换律
TEXCOORD0在输入结构体a2v中表示存储模型的第一组纹理坐标到该变量中
TEXCOORD0在输出结构体v2f中的含义由我们自己决定

uv坐标是二维的，例如(a,b)值的范围=(0,1).
UV坐标就是查找纹理颜色值
如果你的UV是（0.1, 0.1)取得颜色值就是绿色
如果你的UV是  (0.2, 0.8)取得颜色值就是粉色
如果你的UV是（0.7, 0.2)取得颜色值就是蓝色
如果你的UV是（0.9,0.9) 取得颜色值就是黄色
U3D中的纹理贴图的原理应该是你的模型坐标进过顶点变化到投影坐标系，
然后在接下来的片段着色的时候通过传递过来的UV值用 tex2D(_texName, UV)来获取颜色值，
然后渲染到屏幕上。
uv坐标若要进行缩放和平移只需(aScale表示缩放大小,offset表示偏移量):
(a,b)*(aScale,bScale)+(aOffset,bOffset)
纹理采样：tex2D(_MainTex,i.uv):_MainTex是被采样纹理，uv被赋值
高度纹理
法线纹理:
切线空间：模型的每个顶点都有属于自己的切线空间，切线空间的原点就是顶点本身.
z轴：法线，y轴：副切线，x轴：切线;  y是x和z的叉积
顶点切线空间 的定义是：以顶点切线方向为 x 轴，顶点法线方向为 z 轴，
顶点副法线方向为 y 轴得到的坐标空间，
也就是说顶点切线空间下的顶点切线为 (1,0,0), 副法线为 (0,1,0),法线为(0,0,1);
从模型空间变换到切线空间：
假设模型空间下的切线t=(t1,t2,t3) 副法线=b(b1,b2,b3) 法线=n(n1,n2,n3)，变换矩阵=M
则有Mxt=(1,0,0) Mxb=(0,1,0) Mxn=(0,0,1) , 可逆推得到M(-1)xt=(1,0,0) M(-1)xb=(0,1,0) M(-1)xn=(0,0,1)
|a b c| |1| |a| |t1|  |a b c| |0| |b| |b1|  |a b c| |0| |g| |n1|
|d e f|x|0|=|d|=|t2|  |d e f|x|1|=|e|=|b2|  |d e f|x|0|=|h|=|n2|
|g h i| |0| |g| |t3|  |g h i| |0| |h| |b3|  |g h i| |1| |i| |n3|
根据上面可推导出:
M(-1)为:
|t1 b1 n1|
|t2 b2 n2|
|t3 b3 n3|
因为切线，副法线，法线都是单位向量

#在切线空间下计算光照
1.模型顶点从模型空间变换到裁剪空间
2.将纹理偏移值和缩放值与uv做乘积后存放到片元着色器的uv中.
3.获取副法线：法线和切线做叉积再乘以切线的w分量(决定副法线的方向)得到的向量
4.模型空间变换到切线空间的变换矩阵：(切线,副法线,法线)
5.灯光，视线方向从模型空间变换到切线空间
6.对法线贴图进行取样获取像素值,根据像素值可以反推得到切线空间下的法线向量
7.对主贴图进行取样获取像素值，
8.获取环境光光照
9.获取漫反射光照
10.混合以上光照得到最终颜色

#实现的简单透明AlphaTest(只能是全透明或者不透明)
1.模型顶点从模型空间变换到裁剪空间
2.将主贴图的偏移缩放值存放到片元着色器中
3.法线变换到世界空间下
4.获取是世界空间下的灯光方向
5.获取主贴图的像素值
6.根据上面的像素值进行裁剪，透明度小于裁剪值的就不显示
7.计算环境光照
8.获取漫反射光照
9.混合以上光照得到最终颜色

#混合透明的实现AlphaBlend(复杂的模型（弯曲盘绕的）,无法实现全部半透明)
增加混合命令Blend SrcAlpha OneMinusSrcAlpha,修改片元着色器中alpha值即可

#前面两种方法都是关闭了深度写入来实现透明的
开启深度写入来实现ZWrite On即可

获取片元在屏幕中的像素位置:ComputeScreenPos


##需要解决的问题##
1.前向渲染，后向渲染的区别?
frac取小数
floor向下取整
_Time.y 从场景开始加载的时间


#效果实现
1.一个模型，上半部分为红色，下半部分为绿色
